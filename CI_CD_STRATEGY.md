# Docker ECR vs 현재 CI/CD 방식 비교 분석

사용자님께서 질문하신 **"현재 진행 방식(GitHub Actions -> EC2 Build)"**과 **"ECR을 활용한 방식(GitHub Actions -> ECR -> EC2 Pull)"**의 차이점과 최적의 방법에 대해 설명해 드립니다.

## 1. 현재 구축된 방식 (Build on Server)
현재 설정된 CI/CD 파이프라인의 흐름입니다.

1. **GitHub Push** (소스 코드 업로드)
2. **GitHub Actions** (SSH로 EC2 접속)
3. **EC2 내부에서 `git pull`** (최신 코드 받기)
4. **EC2 내부에서 `docker-compose build`** (이미지 빌드)
5. **컨테이너 실행**

### ✅ 장점
- **무료**: 별도의 이미지 저장소 비용(ECR)이 들지 않습니다.
- **설정 간편**: AWS IAM 권한 설정, ECR 로그인 설정 등이 필요 없어 초기 구축이 매우 빠릅니다.
- **즉시 적용**: 별도의 파이프라인 단계가 적어 배포 과정이 단순합니다.

### ❌ 단점 (현재 발생한 문제)
- **서버 리소스 소모**: **EC2 서버가 직접 빌드를 수행**하므로, 빌드 도중에 CPU와 메모리를 많이 사용하여 서버가 느려지거나 멈출(Freezing) 수 있습니다. (이번 장애의 원인)
- **배포 시간**: 매번 서버에서 빌드를 하므로 시간이 걸립니다.

---

## 2. AWS ECR을 활용한 방식 (Container Registry)
일반적으로 기업이나 대규모 프로젝트에서 사용하는 표준 방식입니다.

1. **GitHub Push**
2. **GitHub Actions Runner가 빌드 수행** (GitHub 서버 자원 사용)
3. **빌드된 이미지를 AWS ECR(Elastic Container Registry)에 업로드**
4. **EC2에 SSH 접속**
5. **EC2는 ECR에서 이미지만 다운로드(`docker pull`)하여 실행**

### ✅ 장점
- **서버 안정성**: **무거운 빌드 작업을 GitHub 서버가 대신** 하므로, 운영 중인 EC2 서버에 부담을 주지 않습니다. (무중단, 무장애 배포 유리)
- **버전 관리**: 빌드된 이미지가 ECR에 버전별로 저장되어, 문제 발생 시 즉시 이전 버전으로 롤백(Rollback)이 가능합니다.
- **속도**: EC2는 빌드 없이 다운로드만 하므로 배포 적용이 매우 빠릅니다.

### ❌ 단점
- **비용**: AWS ECR 저장 비용과 데이터 전송 비용이 발생할 수 있습니다. (프리티어는 일정량 무료)
- **설정 복잡**: IAM 권한, ECR 리포지토리 생성, GitHub Secrets 추가 설정 등이 필요합니다.

---

## 🏆 결론 및 최적의 방법 제안

**현재 단계(개인 프로젝트/초기 스타트업)에서는 현재 방식을 유지하되 안정성을 보완하는 것**을 추천해 드립니다.

이유:
1. **비용 효율성**: ECR 비용 절감.
2. **관리 용이성**: 복잡한 AWS 권한 관리 불필요.

### 🛠️ 현재 단점 보완책 (이미 적용함)
서버가 멈추는 문제를 해결하기 위해, 방금 `deploy.yml`에 **Swap Memory(가상 메모리)** 설정을 추가했습니다.
- EC2의 메모리가 부족할 때 하드디스크의 일부를 메모리처럼 사용하여, 속도는 조금 느려지더라도 **서버가 다운되는 것을 완벽하게 방지**합니다.

만약 서비스 규모가 커져서 EC2가 여러 대가 되거나, 배포 빈도가 매우 높아진다면 그때 **ECR 방식**으로 전환하는 것이 가장 효율적인 로드맵입니다.
